#include "udp_demo.h" 
#include "delay.h"
#include "usart.h"
#include "led.h"
#include "key.h"
#include "lcd.h"
#include "malloc.h"
#include "stdio.h"
#include "string.h" 
#include "24cxx.h"
//////////////////////////////////////////////////////////////////////////////////	 
//本程序只供学习使用，未经作者许可，不得用于其它任何用途
//ALIENTEK STM32F407开发板
//UDP 测试代码	   
//正点原子@ALIENTEK
//技术论坛:www.openedv.com
//创建日期:2014/8/15
//版本：V1.0
//版权所有，盗版必究。
//Copyright(C) 广州市星翼电子科技有限公司 2009-2019
//All rights reserved									  
//*******************************************************************************
//修改信息
//无
////////////////////////////////////////////////////////////////////////////////// 	   
 
//UDP接收数据缓冲区
u8 udp_demo_recvbuf[UDP_DEMO_RX_BUFSIZE];	//UDP接收数据缓冲区 
u8 udp_demo_recvbuf2[UDP_DEMO_RX_BUFSIZE];	//UDP接收数据缓冲区 
//UDP发送数据内容
u8 *tcp_demo_sendbuf;

//UDP 测试全局状态标记变量
//bit7:没有用到
//bit6:0,没有收到数据;1,收到数据了.
//bit5:0,没有连接上;1,连接上了.
//bit4~0:保留
u8 udp_demo_flag;
u8 udp_demo_flag2;
extern u8 tcp_client_flag1;	 
extern u8 tcp_client_flag2;	
extern u8 readbuf1_1;
extern u8 readbuf1_2;
extern u8 readbuf2_1;
extern u8 readbuf2_2;
extern u8 * i2srecbuf1;
extern u8 * i2srecbuf2;
extern u8 * i2s3recbuf1;
extern u8 * i2s3recbuf2;

//设置远端IP地址
void udp_demo_set_remoteip(void)
{
	u8 *tbuf;
	u16 xoff;
	u8 key;
	LCD_Clear(WHITE);
	POINT_COLOR=RED;
	LCD_ShowString(30,30,200,16,16,"Explorer STM32F4");
	LCD_ShowString(30,50,200,16,16,"UDP Test");
	LCD_ShowString(30,70,200,16,16,"Remote IP Set");  
	LCD_ShowString(30,90,200,16,16,"KEY0:+  KEY2:-");  
	LCD_ShowString(30,110,200,16,16,"KEY_UP:OK");  
	tbuf=mymalloc(SRAMIN,100);	//申请内存
	if(tbuf==NULL)return;
	//前三个IP保持和DHCP得到的IP一致
	lwipdev.remoteip[0]=lwipdev.ip[0];
	lwipdev.remoteip[1]=lwipdev.ip[1];
	lwipdev.remoteip[2]=lwipdev.ip[2]; 
	sprintf((char*)tbuf,"Remote IP:%d.%d.%d.",lwipdev.remoteip[0],lwipdev.remoteip[1],lwipdev.remoteip[2]);//远端IP
	LCD_ShowString(30,150,210,16,16,tbuf); 
	POINT_COLOR=BLUE;
	xoff=strlen((char*)tbuf)*8+30;
	LCD_ShowxNum(xoff,150,lwipdev.remoteip[3],3,16,0); 
	while(1)
	{
		key=KEY_Scan(0);
		if(key==WKUP_PRES)break;
		else if(key)
		{
			if(key==KEY0_PRES)lwipdev.remoteip[3]++;//IP增加
			if(key==KEY2_PRES)lwipdev.remoteip[3]--;//IP减少
			LCD_ShowxNum(xoff,150,lwipdev.remoteip[3],3,16,0X80);//显示新IP
		}
	}
	myfree(SRAMIN,tbuf); 
} 
extern u8 local_port[2];
extern u8 remote_port[2];
//UDP测试
	struct udp_pcb *udppcb;  	//定义一个TCP服务器控制块
	struct udp_pcb *udppcb2;  	//定义一个TCP服务器控制块
void udp_demo_test(void)
{
 	err_t err;
//	struct udp_pcb *udppcb;  	//定义一个TCP服务器控制块
//	struct udp_pcb *udppcb2;  	//定义一个TCP服务器控制块
	struct ip_addr rmtipaddr;  	//远端ip地址
 	
	u8 *tbuf;
 	u8 key;
	u8 res=0;		
	u8 t=0; 
//	u16 i;
// 	tcp_demo_sendbuf=mymalloc(SRAMIN,TCP_CLIENT_TX_BUFSIZE);
	udp_demo_set_remoteip();//先选择IP
	LCD_Clear(WHITE);	//清屏
	POINT_COLOR=RED; 	//红色字体
	LCD_ShowString(30,30,200,16,16,"Explorer STM32F4");
	LCD_ShowString(30,50,200,16,16,"UDP Test");
	LCD_ShowString(30,70,200,16,16,"ATOM@ALIENTEK");  
	LCD_ShowString(30,90,200,16,16,"KEY0:Send data");  
	LCD_ShowString(30,110,200,16,16,"KEY_UP:Quit"); 
	LCD_ShowString(30,130,200,16,16,"KEY1:Connect");
	tbuf=mymalloc(SRAMIN,200);	//申请内存
	if(tbuf==NULL)return ;		//内存申请失败了,直接退出
	sprintf((char*)tbuf,"Local IP:%d.%d.%d.%d",lwipdev.ip[0],lwipdev.ip[1],lwipdev.ip[2],lwipdev.ip[3]);//服务器IP
	LCD_ShowString(30,150,210,16,16,tbuf);  
	sprintf((char*)tbuf,"Remote IP:%d.%d.%d.%d",lwipdev.remoteip[0],lwipdev.remoteip[1],lwipdev.remoteip[2],lwipdev.remoteip[3]);//远端IP
	LCD_ShowString(30,170,210,16,16,tbuf);  
	sprintf((char*)tbuf,"Remote Port:%d.%d",remote_port[0],remote_port[1]);//服务端端口号
	LCD_ShowString(30,190,210,16,16,tbuf);
	sprintf((char*)tbuf,"local Port:%d.%d",local_port[0],local_port[1]);//客户端端口号
	LCD_ShowString(30,210,210,16,16,tbuf);
	udppcb=udp_new();
	udppcb2=udp_new();
	if(udppcb)//创建成功
	{ 
		IP4_ADDR(&rmtipaddr,lwipdev.remoteip[0],lwipdev.remoteip[1],lwipdev.remoteip[2],lwipdev.remoteip[3]);
		err=udp_connect(udppcb,&rmtipaddr,remote_port[0]);//UDP客户端连接到指定IP地址和端口号的服务器
		if(err==ERR_OK)
		{
			err=udp_bind(udppcb,IP_ADDR_ANY,local_port[0]);//绑定本地IP地址与端口号
			if(err==ERR_OK)	//绑定完成
			{
				udp_recv(udppcb,udp_demo_recv,NULL);//注册接收回调函数 
//				LCD_ShowString(30,210,210,16,16,"STATUS:Connected   ");//标记连接上了(UDP是非可靠连接,这里仅仅表示本地UDP已经准备好)
				udp_demo_flag |= 1<<5;			//标记已经连接上
//				POINT_COLOR=RED;
//				LCD_ShowString(30,230,lcddev.width-30,lcddev.height-190,16,"Receive Data:");//提示消息		
//				POINT_COLOR=BLUE;//蓝色字体
			}else res=1;
		}else res=1;		
	}else res=1;
	if(udppcb2)//创建成功
	{ 
		IP4_ADDR(&rmtipaddr,lwipdev.remoteip[0],lwipdev.remoteip[1],lwipdev.remoteip[2],lwipdev.remoteip[3]);
		err=udp_connect(udppcb2,&rmtipaddr,remote_port[1]);//UDP客户端连接到指定IP地址和端口号的服务器
		if(err==ERR_OK)
		{
			err=udp_bind(udppcb2,IP_ADDR_ANY,local_port[1]);//绑定本地IP地址与端口号
			if(err==ERR_OK)	//绑定完成
			{
				udp_recv(udppcb2,udp_demo_recv2,NULL);//注册接收回调函数 
//				LCD_ShowString(30,210,210,16,16,"STATUS:Connected   ");//标记连接上了(UDP是非可靠连接,这里仅仅表示本地UDP已经准备好)
//				udp_demo_flag2 |= 1<<5;			//标记已经连接上
//				POINT_COLOR=RED;
//				LCD_ShowString(30,230,lcddev.width-30,lcddev.height-190,16,"Receive Data:");//提示消息		
//				POINT_COLOR=BLUE;//蓝色字体
			}else res=1;
		}else res=1;		
	}else res=1;
//	for(i=0;i<TCP_CLIENT_TX_BUFSIZE;i++)
//	{
//	  tcp_demo_sendbuf[i]=0x55;
//	}
	while(res==0)
	{
//		udp_demo_senddata(udppcb);
		key=KEY_Scan(0);
		if(key==WKUP_PRES)break;
		if(udp_demo_flag&1<<6)//是否收到数据?
		{		
			if((udp_demo_recvbuf[0]==0X55)&&(udp_demo_recvbuf[7]==0X88))
			{
			AT24CXX_Write(0,&(udp_demo_recvbuf[1]),UDP_DEMO_RX_BUFSIZE-2);
			}
//			LCD_Fill(30,250,lcddev.width-1,lcddev.height-1,WHITE);//清上一次数据
//			LCD_ShowString(30,250,lcddev.width-30,lcddev.height-230,16,udp_demo_recvbuf);//显示接收到的数据	
//			USART_SendData(USART1,udp_demo_recvbuf[0]);
			udp_demo_flag&=~(1<<6);//标记数据已经被处理了
		} 
		if(udp_demo_flag2&1<<6)//是否收到数据?
		{
			if((udp_demo_recvbuf2[0]==0x55)&&(udp_demo_recvbuf2[7]==0x88))
			{
			AT24CXX_Write(10,&(udp_demo_recvbuf2[1]),UDP_DEMO_RX_BUFSIZE-2);
			}
//			LCD_Fill(30,250,lcddev.width-1,lcddev.height-1,WHITE);//清上一次数据
//			LCD_ShowString(30,250,lcddev.width-30,lcddev.height-230,16,udp_demo_recvbuf2);//显示接收到的数据			
			udp_demo_flag2&=~(1<<6);//标记数据已经被处理了.
		} 
//			udp_demo_senddata2(udppcb2);
			lwip_periodic_handle();



//			delay_ms(1);

		}
	udp_demo_connection_close(udppcb); 
	udp_demo_connection_close(udppcb2); 
	myfree(SRAMIN,tbuf);
} 

//UDP回调函数
void udp_demo_recv(void *arg,struct udp_pcb *upcb,struct pbuf *p,struct ip_addr *addr,u16_t port)
{
	u32 data_len = 0;
	struct pbuf *q;
	if(p!=NULL)	//接收到不为空的数据时
	{
		memset(udp_demo_recvbuf,0,UDP_DEMO_RX_BUFSIZE);  //数据接收缓冲区清零
		for(q=p;q!=NULL;q=q->next)  //遍历完整个pbuf链表
		{
			//判断要拷贝到UDP_DEMO_RX_BUFSIZE中的数据是否大于UDP_DEMO_RX_BUFSIZE的剩余空间，如果大于
			//的话就只拷贝UDP_DEMO_RX_BUFSIZE中剩余长度的数据，否则的话就拷贝所有的数据
			if(q->len > (UDP_DEMO_RX_BUFSIZE-data_len)) memcpy(udp_demo_recvbuf+data_len,q->payload,(UDP_DEMO_RX_BUFSIZE-data_len));//拷贝数据
			else memcpy(udp_demo_recvbuf+data_len,q->payload,q->len);
			data_len += q->len;  	
			if(data_len > UDP_DEMO_RX_BUFSIZE) break; //超出TCP客户端接收数组,跳出	
		}
		upcb->remote_ip=*addr; 				//记录远程主机的IP地址
		upcb->remote_port=port;  			//记录远程主机的端口号
		lwipdev.remoteip[0]=upcb->remote_ip.addr&0xff; 		//IADDR4
		lwipdev.remoteip[1]=(upcb->remote_ip.addr>>8)&0xff; //IADDR3
		lwipdev.remoteip[2]=(upcb->remote_ip.addr>>16)&0xff;//IADDR2
		lwipdev.remoteip[3]=(upcb->remote_ip.addr>>24)&0xff;//IADDR1 
		udp_demo_flag|=1<<6;	//标记接收到数据了
		pbuf_free(p);//释放内存
	}else
	{
		udp_disconnect(upcb); 
		LCD_Clear(WHITE);			//清屏
		POINT_COLOR = RED;
		LCD_ShowString(30,30,200,16,16,"Explorer STM32F4");
		LCD_ShowString(30,50,200,16,16,"UDP Test");
		LCD_ShowString(30,70,200,16,16,"ATOM@ALIENTEK");
		
		POINT_COLOR=BLUE;
		LCD_ShowString(30,90,200,16,16,"Connect break！");  
		LCD_ShowString(30,110,200,16,16,"KEY1:Connect");
		udp_demo_flag &= ~(1<<5);	//标记连接断开
	} 
} 
void udp_demo_recv2(void *arg,struct udp_pcb *upcb,struct pbuf *p,struct ip_addr *addr,u16_t port)
{
	u32 data_len = 0;
	struct pbuf *q;
	if(p!=NULL)	//接收到不为空的数据时
	{
		memset(udp_demo_recvbuf2,0,UDP_DEMO_RX_BUFSIZE);  //数据接收缓冲区清零
		for(q=p;q!=NULL;q=q->next)  //遍历完整个pbuf链表
		{
			//判断要拷贝到UDP_DEMO_RX_BUFSIZE中的数据是否大于UDP_DEMO_RX_BUFSIZE的剩余空间，如果大于
			//的话就只拷贝UDP_DEMO_RX_BUFSIZE中剩余长度的数据，否则的话就拷贝所有的数据
			if(q->len > (UDP_DEMO_RX_BUFSIZE-data_len)) memcpy(udp_demo_recvbuf2+data_len,q->payload,(UDP_DEMO_RX_BUFSIZE-data_len));//拷贝数据
			else memcpy(udp_demo_recvbuf2+data_len,q->payload,q->len);
			data_len += q->len;  	
			if(data_len > UDP_DEMO_RX_BUFSIZE) break; //超出TCP客户端接收数组,跳出	
		}
		upcb->remote_ip=*addr; 				//记录远程主机的IP地址
		upcb->remote_port=port;  			//记录远程主机的端口号
		lwipdev.remoteip[0]=upcb->remote_ip.addr&0xff; 		//IADDR4
		lwipdev.remoteip[1]=(upcb->remote_ip.addr>>8)&0xff; //IADDR3
		lwipdev.remoteip[2]=(upcb->remote_ip.addr>>16)&0xff;//IADDR2
		lwipdev.remoteip[3]=(upcb->remote_ip.addr>>24)&0xff;//IADDR1 
		udp_demo_flag2|=1<<6;	//标记接收到数据了
		pbuf_free(p);//释放内存
	}else
	{
		udp_disconnect(upcb); 
		LCD_Clear(WHITE);			//清屏
		POINT_COLOR = RED;
		LCD_ShowString(30,30,200,16,16,"Explorer STM32F4");
		LCD_ShowString(30,50,200,16,16,"UDP Test");
		LCD_ShowString(30,70,200,16,16,"ATOM@ALIENTEK");
		
		POINT_COLOR=BLUE;
		LCD_ShowString(30,90,200,16,16,"Connect break！");  
		LCD_ShowString(30,110,200,16,16,"KEY1:Connect");
		udp_demo_flag2 &= ~(1<<5);	//标记连接断开
	} 
} 

//UDP服务器发送数据
void udp_demo_senddata(struct udp_pcb *upcb,u8 *sendbuf)
{
	struct pbuf *ptr;
//	if(tcp_client_flag1&(1<<7))	//判断是否有数据要发送 
//	{	
//	ptr=pbuf_alloc(PBUF_TRANSPORT,strlen((char*)tcp_demo_sendbuf),PBUF_POOL); //申请内存
		ptr=pbuf_alloc(PBUF_TRANSPORT,TCP_CLIENT_TX_BUFSIZE,PBUF_POOL); //申请内存
		if(ptr)
		{
		  pbuf_take(ptr,(u8*)sendbuf,TCP_CLIENT_TX_BUFSIZE); //将tcp_demo_sendbuf中的数据打包进pbuf结构中
//			if(readbuf1_1==1){
//			pbuf_take(ptr,(u8*)i2srecbuf1,TCP_CLIENT_TX_BUFSIZE); //将tcp_demo_sendbuf中的数据打包进pbuf结构中
//			readbuf1_1=0;
//			}
//			else if(readbuf1_2==1){
//	    pbuf_take(ptr,(u8*)i2srecbuf2,TCP_CLIENT_TX_BUFSIZE); //将tcp_demo_sendbuf中的数据打包进pbuf结构中
//			readbuf1_2=0;
//			}		
//		pbuf_take(ptr,(char*)tcp_demo_sendbuf,strlen((char*)tcp_demo_sendbuf)); //将tcp_demo_sendbuf中的数据打包进pbuf结构中
			udp_send(upcb,ptr);	//udp发送数据 
			pbuf_free(ptr);//释放内存
//			tcp_client_flag1&=~(1<<7);	//清除数据发送标志
		}
//	} 
} 
void udp_demo_senddata2(struct udp_pcb *upcb,u8 * sendbuf)
{
	struct pbuf *ptr;
//	if(tcp_client_flag2&(1<<7))	//判断是否有数据要发送 
//	{	
//	ptr=pbuf_alloc(PBUF_TRANSPORT,strlen((char*)tcp_demo_sendbuf),PBUF_POOL); //申请内存
		ptr=pbuf_alloc(PBUF_TRANSPORT,TCP_CLIENT_TX_BUFSIZE,PBUF_POOL); //申请内存
		if(ptr)
		{
		  pbuf_take(ptr,(u8*)sendbuf,TCP_CLIENT_TX_BUFSIZE); //将tcp_demo_sendbuf中的数据打包进pbuf结构中
//			if(readbuf2_1==1){
//			pbuf_take(ptr,(u8*)sendbuf,TCP_CLIENT_TX_BUFSIZE); //将tcp_demo_sendbuf中的数据打包进pbuf结构中
//			readbuf2_1=0;
//			}
//			else if(readbuf2_2==1){
//	    pbuf_take(ptr,(u8*)sendbuf,TCP_CLIENT_TX_BUFSIZE); //将tcp_demo_sendbuf中的数据打包进pbuf结构中
//			readbuf2_2=0;
//			}		
//		  pbuf_take(ptr,(char*)tcp_demo_sendbuf,strlen((char*)tcp_demo_sendbuf)); //将tcp_demo_sendbuf中的数据打包进pbuf结构中
			udp_send(upcb,ptr);	//udp发送数据 
			pbuf_free(ptr);//释放内存
//			tcp_client_flag2&=~(1<<7);	//清除数据发送标志
		}
//	} 
}
//关闭UDP连接
void udp_demo_connection_close(struct udp_pcb *upcb)
{
	udp_disconnect(upcb); 
	udp_remove(upcb);			//断开UDP连接 
	udp_demo_flag &= ~(1<<5);	//标记连接断开
	LCD_Clear(WHITE);			//清屏
	POINT_COLOR = RED;
	LCD_ShowString(30,30,200,16,16,"Explorer STM32F4");
	LCD_ShowString(30,50,200,16,16,"UDP Test");
	LCD_ShowString(30,70,200,16,16,"ATOM@ALIENTEK");
	
	POINT_COLOR=BLUE;
	LCD_ShowString(30,90,200,16,16,"Connect break！");  
	LCD_ShowString(30,110,200,16,16,"KEY1:Connect");
}

























